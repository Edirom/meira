<?xml version="1.0" encoding="UTF-8" ?>
<elementDefinition
    xmlns="NS:DEF"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xlink="http://www.w3.org/1999/xlink">

<element name="beam">
  <properties>
    <elementReference name="start" lacuna=".."/>
    <elementReference name="end" lacuna=".."/>
    
                               <!-- Select first stem of start element; if there is none, simply pick the start element -->
    <coordinate name="x1" orientation="x" anchor="g:x((g:start(.)//musx:stem, g:start(.))[1])" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x((g:end(.)//musx:stem, g:end(.))[1])" lacuna="0"/>
    <!-- TODO: Take into account stem width -->
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
    <coordinate name="x" orientation="x" anchor="g:x1(.)" lacuna="0"/>
    <!-- TODO: GO ON HERE, implement lacuna y -->
    <coordinate name="y" orientation="y" anchor="g:y(..)" lacuna="g:beamYLacuna(.)"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    <scaleFactor name="width" anchor="g:size(.)" lacuna="1"/>
    <scaleFactor name="distance" anchor="g:size(.)" lacuna="1.5"/>
    
    <!-- The caluclateDirection function is defined in note.def -->
    <integer name="direction" lacuna="g:calculateDirection(.)"/>
    <integer name="number" lacuna="1"/>
    
  </properties>

  <xsl:function name="g:beamYLacuna">
    <xsl:param name="beam"/>
    <xsl:variable name="direction" select="g:direction($beam)"/>
    <xsl:variable name="steps" select="g:step(key('beamNotes',$beam/@xml:id,$beam/ancestor::musx:musx))"/>
    <xsl:variable name="centerStep" select="g:lines($beam/ancestor::musx:staff[last()]) - 1"/>
    <xsl:variable name="staffSize" select="g:staffSize($beam)"/>
    <xsl:variable name="stepsSortedInBeamDirection" as="xs:double*">
      <xsl:for-each select="$steps">
        <xsl:sort select=". * $direction"/>
        <xsl:sequence select=". * $direction"/>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="stepClosestToBeam" select="$stepsSortedInBeamDirection[last()] - $centerStep * $direction"/>
    <xsl:variable name="stepFurthestFromBeam" select="$stepsSortedInBeamDirection[1] - $centerStep * $direction"/>
    <xsl:variable name="beamHeightInSteps" select="((g:summedBeamNumber($beam) - 1) * g:distance($beam) + g:width($beam)) div $staffSize"/>
    
    <xsl:variable name="beamStepsFromCenter" select="
        max((
          0, 
          $stepClosestToBeam + 4 + $beamHeightInSteps, 
          $stepFurthestFromBeam + 7
        ))"/>
    <xsl:sequence select="($direction * $beamStepsFromCenter + $centerStep) * $staffSize"/>
<!--    <xsl:message>
      $direction = <xsl:value-of select="$direction"/>
      notes = <xsl:copy-of select="key('beamNotes',$beam/@xml:id,$beam)"/>
      $steps = <xsl:value-of select="$steps"/>
      $centerStep = <xsl:value-of select="$centerStep"/>
      $staffSize = <xsl:value-of select="$staffSize"/>
      $stepsSortedInBeamDirection = <xsl:value-of select="$stepsSortedInBeamDirection"/>
      $stepClosestToBeam = <xsl:value-of select="$stepClosestToBeam"/>
      $stepFurthestFromBeam = <xsl:value-of select="$stepFurthestFromBeam"/>
      $beamHeightInSteps = <xsl:value-of select="$beamHeightInSteps"/>
      $beamStepsFromCenter = <xsl:value-of select="$beamStepsFromCenter"/>
      $resultStep = <xsl:sequence select="($direction * $beamStepsFromCenter - $centerStep)"/>
    </xsl:message>-->
  </xsl:function>

  <xsl:function name="g:summedBeamNumber">
    <xsl:param name="beam" as="node()*"/>
    <xsl:for-each select="$beam">
      <xsl:sequence select="max((g:summedBeamNumber($beam/musx:subbeam), 0)) + g:number($beam)"/>
    </xsl:for-each>
  </xsl:function>

  <xsl:function name="g:beamY">
    <xsl:param name="stem"/>
    <xsl:variable name="beam" select="g:beam($stem)"/>
    <!-- Use basic line equation 
      y = mx + n 
      to calculate y at point x.  We move x1 of the beam to the origin, therefore we have
      y = m(x-x1) + n
      Our y-intercept is then y1, therefore
      y = m(x-x1) + y1
      m is the usual difference quotient, therefore
      y = (y2-y1)/(x2-x1) * (x-x1) + y1
      We must be careful not to divide by zero (if x2-x1=0)
    -->
    <xsl:variable name="dx" select="g:x2($beam) - g:x1($beam)"/>
    <xsl:choose>
      <xsl:when test="$dx = 0">
        <xsl:sequence select="g:y1($beam)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="m" select="(g:y2($beam) - g:y1($beam)) div $dx"/>
        <xsl:sequence select="$m * (g:x($stem) - g:x1($beam)) + g:y1($beam)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
<!--  <xsl:key name="beamNotes" match="musx:note" use="(.//@beam|parent::musx:chord/@beam)[1]"/>-->
  <xsl:key name="beamNotes" match="musx:note" use="musx:stem/@beam"/>
  
  <xsl:template name="drawBeam">
    <xsl:param name="number" select="g:number(.)"/>
    <xsl:param name="direction" select="g:direction(.)"/>
    <xsl:param name="points">
      <xsl:variable name="x1" select="g:x1(.)"/>
      <xsl:variable name="x2" select="g:x2(.)"/>
      <xsl:variable name="y1" select="g:y1(.)"/>
      <xsl:variable name="y2" select="g:y2(.)"/>
      <xsl:variable name="directedWidth" select="$direction * g:width(.)"/>
      <xsl:value-of select="concat($x1,',',$y1,' ',
                                   $x2,',',$y2,' ',
                                   $x2,',',$y2 - $directedWidth,' ',
                                   $x1,',',$y1 - $directedWidth)"/>
    </xsl:param> 
    <xsl:param name="yIncrement" select="g:distance(.)*$direction"/>
    <xsl:param name="yTranslate" select="0"/>
    
    
    <xsl:if test="$number &gt; 0">
      <svg:polygon points="{$points}" transform="translate(0,{$yTranslate})"/>
      <xsl:call-template name="drawBeam">
        <xsl:with-param name="yIncrement" select="$yIncrement"/>
        <xsl:with-param name="yTranslate" select="$yTranslate - $yIncrement"/>
        <xsl:with-param name="points" select="$points"/>
        <xsl:with-param name="number" select="$number - 1"/>
      </xsl:call-template>
    </xsl:if>
    
  </xsl:template>
  
  <draw>
<!--    <xsl:message>
      <xsl:copy-of select="key('beamNotes',@xml:id)"/>
    </xsl:message>-->
    <xsl:call-template name="drawBeam"/>
  </draw>
  
<!--  <OwnBoundingBox>
    <BoundingBox left="{g:x(.)}" right="{g:x(.)}" top="{min((g:y1(.),g:y2(.)))}" bottom="{max((g:y1(.),g:y2(.)))}"/>
  </OwnBoundingBox>-->
</element>
  
<element name="subbeam">
  <properties>
    <elementReference name="start" lacuna="g:start(..)"/>
    <elementReference name="end" lacuna="g:end(..)"/>
    
    <!-- Select first stem of start element; if there is none, simply pick the start element -->
    <coordinate name="x1" orientation="x" anchor="g:x((g:start(.)//musx:stem, g:start(.))[1])" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x((g:end(.)//musx:stem, g:end(.))[1])" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y1(..)" lacuna="- g:distance(..) * g:direction(..) * g:number(..)"/>
    <coordinate name="y2" orientation="y" anchor="g:y2(..)" lacuna="- g:distance(..) * g:direction(..) * g:number(..)"/>
    
    <coordinate name="x" orientation="x" anchor="g:x1(.)" lacuna="0"/>
    <coordinate name="y" orientation="y" anchor="g:y1(.)" lacuna="0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    <scaleFactor name="width" anchor="g:width(..)" lacuna="1"/>
    <scaleFactor name="distance" anchor="g:distance(..)" lacuna="1"/>
    
    <integer name="direction" lacuna="g:direction(..)"/>
    <integer name="number" lacuna="1"/>
  </properties>
  
  <draw>
    <xsl:call-template name="drawBeam"/>
  </draw>
</element>

</elementDefinition> 