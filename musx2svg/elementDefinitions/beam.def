<?xml version="1.0" encoding="UTF-8" ?>
<elementDefinition
    xmlns="NS:DEF"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xlink="http://www.w3.org/1999/xlink">

<element name="beam">
  <properties>
    <elementReference name="start" lacuna=".."/>
    <elementReference name="end" lacuna=".."/>
    
                               <!-- Select first stem of start element; if there is none, simply pick the start element -->
    <coordinate name="x1" orientation="x" anchor="g:x((g:start(.)//musx:stem, g:start(.))[1])" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x((g:end(.)//musx:stem, g:end(.))[1])" lacuna="0"/>
    <!-- TODO: Take into account stem width -->
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
    <coordinate name="x" orientation="x" anchor="g:x1(.)" lacuna="0"/>
    <!-- TODO: GO ON HERE, implement lacuna y -->
    <coordinate name="y" orientation="y" anchor="g:y(..)" lacuna="0(:
        for $centerStep in g:lines(g:staff(.)) - 1,
            $note in key('beamNotes',@xml:id)
        return
          if (step(.) 
          then
          else:)"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    <scaleFactor name="width" anchor="g:size(.)" lacuna="1"/>
    <scaleFactor name="distance" anchor="g:size(.)" lacuna="1.5"/>
    
    <!-- The caluclateDirection function is defined in note.def -->
    <integer name="direction" lacuna="g:calculateDirection(.)"/>
    <integer name="number" lacuna="1"/>
  </properties>
  
  <xsl:function name="g:beamY">
    <xsl:param name="stem"/>
    <xsl:variable name="beam" select="g:beam($stem)"/>
    <!-- Use basic line equation 
      y = mx + n 
      to calculate y at point x.  We move x1 of the beam to the origin, therefore we have
      y = m(x-x1) + n
      Our y-intercept is then y1, therefore
      y = m(x-x1) + y1
      m is the usual difference quotient, therefore
      y = (y2-y1)/(x2-x1) * (x-x1) + y1
      We must be careful not to divide by zero (if x2-x1=0)
    -->
    <xsl:variable name="dx" select="g:x2($beam) - g:x1($beam)"/>
    <xsl:choose>
      <xsl:when test="$dx = 0">
        <xsl:sequence select="g:y1($beam)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="m" select="(g:y2($beam) - g:y1($beam)) div $dx"/>
        <xsl:sequence select="$m * (g:x($stem) - g:x1($beam)) + g:y1($beam)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:key name="beamNotes" match="musx:note[.//@beam]" use=".//@beam[1]"/>
  
  <xsl:template name="drawBeam">
    <xsl:param name="number" select="g:number(.)"/>
    <xsl:param name="direction" select="g:direction(.)"/>
    <xsl:param name="points">
      <xsl:variable name="x1" select="g:x1(.)"/>
      <xsl:variable name="x2" select="g:x2(.)"/>
      <xsl:variable name="y1" select="g:y1(.)"/>
      <xsl:variable name="y2" select="g:y2(.)"/>
      <xsl:variable name="directedWidth" select="$direction * g:width(.)"/>
      <xsl:value-of select="concat($x1,',',$y1,' ',
                                   $x2,',',$y2,' ',
                                   $x2,',',$y2 - $directedWidth,' ',
                                   $x1,',',$y1 - $directedWidth)"/>
    </xsl:param> 
    <xsl:param name="yIncrement" select="g:distance(.)*$direction"/>
    <xsl:param name="yTranslate" select="0"/>
    
    
    <xsl:if test="$number &gt; 0">
      <svg:polygon points="{$points}" transform="translate(0,{$yTranslate})"/>
      <xsl:call-template name="drawBeam">
        <xsl:with-param name="yIncrement" select="$yIncrement"/>
        <xsl:with-param name="yTranslate" select="$yTranslate - $yIncrement"/>
        <xsl:with-param name="points" select="$points"/>
        <xsl:with-param name="number" select="$number - 1"/>
      </xsl:call-template>
    </xsl:if>
    
  </xsl:template>
  
  <draw>
    <xsl:call-template name="drawBeam"/>
  </draw>
  
<!--  <OwnBoundingBox>
    <BoundingBox left="{g:x(.)}" right="{g:x(.)}" top="{min((g:y1(.),g:y2(.)))}" bottom="{max((g:y1(.),g:y2(.)))}"/>
  </OwnBoundingBox>-->
</element>
  
<element name="subbeam">
  <properties>
    <elementReference name="start" lacuna="g:start(..)"/>
    <elementReference name="end" lacuna="g:end(..)"/>
    
    <!-- Select first stem of start element; if there is none, simply pick the start element -->
    <coordinate name="x1" orientation="x" anchor="g:x((g:start(.)//musx:stem, g:start(.))[1])" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x((g:end(.)//musx:stem, g:end(.))[1])" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y1(..)" lacuna="- g:distance(..) * g:direction(..) * g:number(..)"/>
    <coordinate name="y2" orientation="y" anchor="g:y2(..)" lacuna="- g:distance(..) * g:direction(..) * g:number(..)"/>
    
    <coordinate name="x" orientation="x" anchor="g:x1(.)" lacuna="0"/>
    <coordinate name="y" orientation="y" anchor="g:y1(.)" lacuna="0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    <scaleFactor name="width" anchor="g:width(..)" lacuna="1"/>
    <scaleFactor name="distance" anchor="g:distance(..)" lacuna="1"/>
    
    <integer name="direction" lacuna="g:direction(..)"/>
    <integer name="number" lacuna="1"/>
  </properties>
  
  <draw>
    <xsl:call-template name="drawBeam"/>
  </draw>
</element>

</elementDefinition> 