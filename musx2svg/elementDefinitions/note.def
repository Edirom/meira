<?xml version="1.0" encoding="UTF-8" ?>
<elementDefinition
    xmlns="NS:DEF"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xlink="http://www.w3.org/1999/xlink">

<element name="note">
  <properties>
    <elementReference name="start" lacuna=".."/>
    
    <coordinate name="x" orientation="x" anchor="g:x(g:start(.))" lacuna="0"/>
    <coordinate name="y" orientation="y" anchor="g:y(..)" lacuna="0"/>
    
    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
    <integer name="ledgerLines.direction" lacuna="if (g:step(.) &lt; 0)
                                                  then -1
                                                  else 1"/>
    <coordinate name="ledgerLines.y1" orientation="y" lacuna="0" anchor="
      for $staff in ancestor::musx:staff[last()] return
        if (g:ledgerLines.direction(.) &lt; 0)
        then g:y1($staff) - 2*g:size($staff)
        else g:y2($staff) + 2*g:size($staff)"/>
    <!-- QUESTION: Is it necessary to refine this? -->
    <coordinate name="ledgerLines.y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <boolean name="ledgerLines.draw" lacuna="g:step(.) &lt; -1 or g:step(.) &gt; 9"/>
    <scaleFactor name="ledgerLines.protrusion" anchor="g:size(..)" lacuna=".75"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
    <!-- Following the SVG coordinate system, "1" means stem down, "-1" means stem up -->
    <!-- QUESTION: Is there a general rule for staffs with other than 5 lines?
                   Especially, what about staffs with an even number of liens?
                   What about staffs with 1 or 0 lines? -->
    <integer name="direction" lacuna="
        if (musx:stem/@direction)
        then g:direction(musx:stem[1])
        else if (g:step(.) &lt; g:lines(ancestor::musx:staff))
        then 1
        else -1"/>

    <!-- The following is only meant to implement a getter function g:step(.). 
         QUESTION: Prevent this from being explicitly set as an attribute? -->
    <!-- Usually, @y should be given with the 'S' unit.  The else branch would work for
         any unit, but is much more inefficient for the typical case. -->
    <number name="step" lacuna="
          if(substring(@y,1,1)='S')
          then number(substring(@y,2))
          else (g:y(.) - g:y(ancestor::musx:staff)) div g:size(ancestor::musx:staff[last()])"/>
    
  </properties>
  
  <xsl:template name="addLedgerLines">
    <!-- QUESTION: Allow shortened ledger lines after accidentals? (like Lilypond) -->
    <!-- $direction is set to -1 if head is above staff, else 1 -->
    <xsl:param name="direction" select="g:ledgerLines.direction(.)"/>
    <xsl:param name="staffSize" select="g:size(ancestor::musx:staff[last()])"/>
    <xsl:param name="increment" select="2 * $direction * $staffSize"/>
    <xsl:param name="y" select="g:ledgerLines.y1(.)"/>
    <xsl:param name="headBoundingBox" select="g:OwnBoundingBox(musx:head)"/>
    <xsl:param name="protrusion"  select="g:ledgerLines.protrusion(.)"/>
    <xsl:param name="x1" select="number($headBoundingBox//@left) - $protrusion"/>
    <xsl:param name="x2" select="number($headBoundingBox//@right) + $protrusion"/>
    <xsl:param name="finalYPlusTolerance" select="$direction * g:y(.) + .5 * $staffSize"/>
           <!-- Added tolerance ".5 * $staffSize" is for avoiding missed ledgerLines because of rounding errors -->
    
    <xsl:if test="$direction*$y &lt; $finalYPlusTolerance">
      <svg:line x1="{$x1}" x2="{$x2}" y1="{$y}" y2="{$y}"/>
      <xsl:call-template name="addLedgerLines">
        <xsl:with-param name="increment" select="$increment"/>
        <xsl:with-param name="y" select="$y + $increment"/>
        <xsl:with-param name="x1" select="$x1"/>
        <xsl:with-param name="x2" select="$x2"/>
        <xsl:with-param name="finalYPlusTolerance" select="$finalYPlusTolerance"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
  
  <draw>
    <svg:g class="ledgerlines" stroke="currentColor">
      <xsl:call-template name="addLedgerLines"/>
    </svg:g>
  </draw>
  
  <OwnBoundingBox>
    <xsl:if test="g:ledgerLines.draw(.)">
      <xsl:variable name="headBoundingBox" select="g:OwnBoundingBox(musx:head)"/>
      <xsl:variable name="protrusion" select="g:ledgerLines.protrusion(.)"/>
      <xsl:variable name="y1" select="g:ledgerLines.y1(.)"/>
      <xsl:variable name="headY" select="g:y(musx:head)"/>
      <BoundingBox left="{number($headBoundingBox//@left) - $protrusion}"
                   right="{number($headBoundingBox//@right) + $protrusion}"
                   top="{min(($headY,$y1))}"
                   bottom="{max(($headY,$y1))}"/>
    </xsl:if>
  </OwnBoundingBox>

</element>
  
<element name="head">
  <properties>
    <coordinate name="x" orientation="x" anchor="g:x(g:start(.))" lacuna="
      if (g:flip(.) = 0)
      then 0
      else g:flip(.) * number(g:svgSymbolBoundingBox(g:symbol(.))//@right) * g:size(.)"/>
    <coordinate name="y" orientation="y" anchor="g:y(..)" lacuna="0"/>
    
    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
<!--    <integer name="flip" lacuna="
        if(parent::musx:note)
        then 0
        else 
          for $chordDirection in g:direction(../..),
              $noteStep in g:step(..),
              (: If there is no colliding note, there's nothing returned, but integers default to 0 anyway :)
              $collidingNote in ../../musx:note[g:step(.) = $noteStep - $chordDirection] 
          return
            1 (:(g:flip(../../musx:note[g:step(.) = $step - $direction]) + $direction) mod 2:)"/>
-->    
    <integer name="flip" lacuna="
      if(../parent::musx:chord)
      then (
        for $chordDirection in g:direction(../..),
            $noteStep in g:step(..),
            $collisionStep in $noteStep - $chordDirection,
            $otherNote in ../../musx:note
        return
          if (g:step($otherNote) = $collisionStep)
          then (g:flip($otherNote/musx:head) - $chordDirection) mod 2
          else ()
      )[1]
      else 0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
    <symbol name="symbol" lacuna="'notehead.quarter'"/>
    
  </properties>
  
  <draw svg:fill="currentColor">
    <xsl:if test="ancestor::musx:chord">
      <xsl:message>
        g:flip(.) = <xsl:copy-of select="g:flip(.)"/>
      </xsl:message>
    </xsl:if>
    <svg:use transform="translate({g:x(.)},{g:y(.)}) scale({g:size(.)})" xlink:href="{g:symbol(.)}"/>
  </draw>
  
</element>

<element name="accidental">
  <properties>
    <coordinate name="x" orientation="x" anchor="g:x(..)" lacuna="-3*g:size(.)"/>
    <coordinate name="y" orientation="y" anchor="g:y(..)" lacuna="0"/>
    
    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
    <symbol name="symbol" lacuna="''"/>
    
  </properties>
  
  <draw>
    <svg:use transform="translate({g:x(.)},{g:y(.)}) scale({g:size(.)})" xlink:href="{g:symbol(.)}"/>
  </draw>
  
</element>
  
  
<element name="stem">
  <properties>
    <!-- lacuna is set to 0 for downstem and to the right of the notehead if upstem -->
    <coordinate name="x" orientation="x" anchor="g:x(..)" lacuna="
        if (g:direction(.) = 1 or not(..//musx:head))
        then 0
        else 
          for $startNote in 
                if (parent::musx:chord)
                then g:topNote(..)
                else ..,
              $headSymbol in g:symbol($startNote/musx:head[1])
          return number(g:svgSymbolBoundingBox($headSymbol)//@right) * g:size($startNote)"/>
    <coordinate name="y1" orientation="y" anchor="g:y1(..)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y2(..)" lacuna="g:direction(.) * g:length(.) * g:size(ancestor::musx:staff[last()])"/>

    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="y" orientation="y" anchor="g:y1(.)" lacuna="0"/>
    
    <integer name="direction" lacuna="g:direction(..)"/>
    
    <!-- Stems length is determined as follows (inspired by Lilypond/Musescore):
       - Notes with a stem pointing towards staff center that are more than 7 steps away from staff center 
         (positive $distanceFromCenter, > 7) get length that's equal to said distance
       - notes with a stem pointing towards staff center that are between 7 and 0 steps away from staff center
         ($distanceFromCenter between 0 and 7) get a stem length of 7
       - notes with a stem pointing away from staff center that are more than 5 steps away from staff center
         ($distanceFromCenter negative, -5 and less), get a shortened stem length of 5  
       - notes with a stem pointing away from staff center that are 0 and 5 steps away from staff center
         ($distanceFromCenter negative between 0 and -5), get their length linearly interpolated between the 
         stem lengths of notes that are 0 and "-5" steps away from center 
       If the height of the flag symbol is greater than the so determined length, the flag height determines
       the stem length -->
    <number name="length" lacuna="
      max((
        for $direction in g:direction(.),
            $stemOutletStep in   (: QUESTION: Find a better name? 'outletStep' is where the stem 'leaves' a chord :)  
              if (parent::musx:note)
              then g:step(..)
              else (:chord:) if ($direction = 1)
              then g:step(g:bottomNote(..))
              else g:step(g:topNote(..)),
            $distanceFromCenter in g:direction(.) * (g:lines(ancestor::musx:staff[last()]) - 1 - $stemOutletStep) 
        return
          if ($distanceFromCenter &gt; 7)
            then $distanceFromCenter
          else if ($distanceFromCenter &gt;= 0)
            then 7
          else if ($distanceFromCenter &gt; -5)
            then .4 * $distanceFromCenter + 7
          else 5
        ,
        if (musx:flags)  (: if there are flags, the stem must be at least as long as the flags symbol :) 
        then for $symbolBB in g:svgSymbolBoundingBox(g:symbol(musx:flags)) return
             max((abs($symbolBB//@top),abs($symbolBB//@bottom))) 
             + (if (g:direction(.) = 1) then 1 else 0)
             (: For downstemmed notes, we need to make the stem at least one step longer than the flag 
             because otherwise the flag runs into the head :)
        else ()
      ))"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
  </properties>
  
  <draw>
    <svg:line x1="{g:x1(.)}" x2="{g:x2(.)}" y1="{g:y1(.)}" y2="{g:y2(.)}" stroke="currentColor"/>
  </draw>
  
  <OwnBoundingBox>
    <BoundingBox left="{g:x(.)}" right="{g:x(.)}" top="{min((g:y1(.),g:y2(.)))}" bottom="{max((g:y1(.),g:y2(.)))}"/>
  </OwnBoundingBox>
</element>
  

<element name="flags">
  <properties>
    <coordinate name="x" orientation="x" anchor="g:x(..)" lacuna="0"/>
    <coordinate name="y" orientation="y" anchor="g:y2(..)" lacuna="0"/>
    
    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="g:y(.)" lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="g:y(.)" lacuna="0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
    <integer name="direction" lacuna="g:direction(..)"/>
    <integer name="number" lacuna="1"/>
    
    <symbol name="symbol" lacuna="concat('flags.',g:direction(.)*g:number(.))"/>
    
  </properties>
  
  <draw>
    <svg:use transform="translate({g:x(.)},{g:y(.)}) scale({g:size(.)})" xlink:href="{g:symbol(.)}"/>
  </draw>
</element>
  
<element name="chord">
  <properties>
    <elementReference name="start" lacuna=".."/>
    
    <elementReference name="topNote" lacuna="musx:note[g:step(.) = min(g:step(../musx:note))][1]"/>
    <elementReference name="bottomNote" lacuna="musx:note[g:step(.) = max(g:step(../musx:note))][1]"/>
    <integer name="direction" lacuna="
        if (musx:stem/@direction)
        then g:direction(musx:stem[1])
        else for $meanStepValue in .5*(g:step(g:bottomNote(.)) + g:step(g:topNote(.))),
                 $centerStep in g:lines(ancestor::musx:staff[last()]) - 1
        return if ($meanStepValue &gt; $centerStep)
               then -1
               else 1"/>
    
    <coordinate name="x" orientation="x" anchor="g:x(g:start(.))" lacuna="0"/>
    <coordinate name="y1" orientation="y" anchor="
      if (g:direction(.) = -1)
      then g:y(g:bottomNote(.))
      else g:y(g:topNote(.))       " lacuna="0"/>
    <coordinate name="y2" orientation="y" anchor="
      if (g:direction(.) = 1)
      then g:y(g:bottomNote(.))
      else g:y(g:topNote(.))      " lacuna="0"/>
    
    <coordinate name="x1" orientation="x" anchor="g:x(.)" lacuna="0"/>
    <coordinate name="x2" orientation="x" anchor="g:x(.)" lacuna="0"/>

    <coordinate name="y" orientation="y" anchor="g:y1(.)" lacuna="0"/>
    
    <scaleFactor name="size" anchor="g:size(..)" lacuna="1"/>
    
  </properties>
  
  <draw/>
</element>
  
</elementDefinition> 